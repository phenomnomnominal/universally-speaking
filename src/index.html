<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>ðŸš€ Universally Speaking ðŸš€</title>
  <base href="/">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
</head>
<body>
  <us-root></us-root>
</body>
<script type="x-shader/x-vertex" id="vertexshader">
  // MIT License.
  // Copyright Ian Webster 2012 (asterank.com)
  // https://github.com/typpo/asterank/blob/master/LICENSE
  #define pi 3.141592653589793238462643383279

  attribute vec3 value_color;
  varying vec3 vColor;

  attribute float size;

  uniform float earth_i;
  uniform float earth_om;

  uniform float jed;

  attribute float a;
  attribute float e;
  attribute float i;
  attribute float o;
  attribute float P;
  attribute float ma;
  attribute float n;
  attribute float w;
  attribute float epoch;

  attribute float is_planet;
  varying float vLocked;
  varying float vPlanet;

  vec3 getAstroPos() {
    float i_rad = i * pi/180.0;
    float o_rad = o * pi/180.0; // longitude of ascending node
    float p_rad = w * pi/180.0; // LONGITUDE of perihelion
    float ma_rad = ma * pi/180.0;

    // Calculate mean anomaly at jed.
    float n_rad;
    if (n > 0.) {
      n_rad = n * pi/180.0; // mean motion
    } else {
      n_rad = 2.0 * pi / P;
    }

    float d = jed - epoch;
    float M = ma_rad + n_rad * d;

    // Estimate eccentric and true anom using iterative approx.
    float E0 = M;
    float E1;
    float lastdiff;
    // converted do/while:
    for (int iter=0; iter < 1000; iter++) {
      E1 = M + e * sin(E0);
      lastdiff = abs(E1-E0);
      E0 = E1;
      if (lastdiff < 0.0000001) {
        break;
      }
    }

    float E = E0;
    float v = 2.0 * atan(sqrt((1.0+e)/(1.0-e)) * tan(E/2.0));

    // radius vector, in AU
    float r = a * (1.0 - e*e) / (1.0 + e * cos(v)) * 50.;  // 50 pixels per AU

    // heliocentric coords
    float X = r * (cos(o_rad) * cos(v + p_rad - o_rad) - sin(o_rad) * sin(v + p_rad - o_rad) * cos(i_rad));
    float Y = r * (sin(o_rad) * cos(v + p_rad - o_rad) + cos(o_rad) * sin(v + p_rad - o_rad) * cos(i_rad));
    float Z = r * (sin(v + p_rad - o_rad) * sin(i_rad));
    return vec3(X, Y, Z);
  }

  void main() {
    vColor = value_color;
    vPlanet = is_planet;

    vec3 newpos = getAstroPos();
    vec4 mvPosition = modelViewMatrix * vec4(newpos, 1.0);
    gl_Position = projectionMatrix * mvPosition;
    gl_PointSize = size;
  }
</script>
<script type="x-shader/x-fragment" id="fragmentshader">
  // MIT License.
  // Copyright Ian Webster 2012 (asterank.com)
  // https://github.com/typpo/asterank/blob/master/LICENSE
  varying vec3 vColor;
  varying float vLocked;
  varying float vPlanet;
  uniform sampler2D planet_texture;
  uniform sampler2D small_roid_texture;
  uniform sampler2D small_roid_circled_texture;

  void main() {
    if (vLocked < .5) {
      if (vPlanet < .5) {
        gl_FragColor = vec4(vColor, 1.0) * texture2D(small_roid_texture,
          vec2(gl_PointCoord.x, 1.0 - gl_PointCoord.y));
      }
      else {
        gl_FragColor = vec4(vColor, 1.0) * texture2D(planet_texture,
          vec2(gl_PointCoord.x, 1.0 - gl_PointCoord.y));
      }
    }
    else {
      gl_FragColor = vec4(vColor, 1.0) * texture2D(small_roid_circled_texture,
        vec2(gl_PointCoord.x, 1.0 - gl_PointCoord.y));
    }
  }
</script>

<script type="application/x-glsl" id="sky-vertex">
varying vec2 vUV;

void main() {
  vUV = uv;
  vec4 pos = vec4(position, 1.0);
  gl_Position = projectionMatrix * modelViewMatrix * pos;
}
</script>

<script type="application/x-glsl" id="sky-density">
uniform sampler2D texture;
varying vec2 vUV;

void main() {
  vec4 sample = texture2D(texture, vUV);
  gl_FragColor = vec4(sample.xyz, sample.w);
}
</script>
</html>
